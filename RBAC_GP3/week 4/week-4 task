import json
import os
from typing import List, Dict, Any
import numpy as np


class ChunkSelector:
    def __init__(self, config_path: str = None):
        """
        Load selection configuration from selection_config.json
        """
        if config_path is None:
            config_path = os.path.join(
                os.path.dirname(__file__),
                "..",
                "config",
                "selection_config.json"
            )

        with open(config_path, "r") as f:
            self.config = json.load(f)

        self.top_k = self.config.get("top_k", 5)
        self.similarity_threshold = self.config.get("similarity_threshold", 0.3)
        self.max_context_tokens = self.config.get("max_context_tokens", 2000)
        self.diversity_weight = self.config.get("diversity_weight", 0.2)

    def calculate_similarity(self, embedding1: List[float], embedding2: List[float]) -> float:
        """
        Calculate cosine similarity between two embeddings
        """
        v1 = np.array(embedding1)
        v2 = np.array(embedding2)

        if np.linalg.norm(v1) == 0 or np.linalg.norm(v2) == 0:
            return 0.0

        return float(np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2)))

    def select_chunks(
        self,
        query_embedding: List[float],
        all_chunks: List[Dict[str, Any]],
        user_role: str
    ) -> List[Dict[str, Any]]:
        """
        Select top-K relevant chunks for the query using similarity scoring and RBAC
        """

        scored_chunks = []

        for chunk in all_chunks:
            # RBAC filtering
            allowed_roles = chunk.get("allowed_roles", [])
            if allowed_roles and user_role not in allowed_roles:
                continue

            chunk_embedding = chunk.get("embedding")
            if chunk_embedding is None:
                continue

            similarity = self.calculate_similarity(query_embedding, chunk_embedding)

            if similarity >= self.similarity_threshold:
                scored_chunks.append({
                    "chunk": chunk,
                    "similarity": similarity
                })

        # Edge case: no relevant chunks
        if not scored_chunks:
            print("Selected 0 chunks with avg similarity 0.0")
            return [{
                "content": "No relevant context found for this query.",
                "similarity": 0.0
            }]

        # Sort by similarity (descending)
        scored_chunks.sort(key=lambda x: x["similarity"], reverse=True)

        # Select top-K
        selected = scored_chunks[:self.top_k]

        avg_similarity = sum(c["similarity"] for c in selected) / len(selected)

        print(f"Selected {len(selected)} chunks with avg similarity {avg_similarity:.4f}")

        return selected
